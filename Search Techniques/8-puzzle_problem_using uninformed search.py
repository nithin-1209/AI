# -*- coding: utf-8 -*-
"""420251

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dz5a4LzfJcmZnZ6yu1XLaLOCFyiGJUjj
"""

#class to define a node in search space

# The Node class is used to create a node object that contains the state of the board, the parent
# node, the level of the node, and the location of the empty space
class Node:
    def __init__(self, state, parent, level, empty):
        self.state = state
        self.parent = parent
        self.level = level
        self.empty = empty

#Check if empty block can move to a particular side
    
def isFeasible(node, action):
   # """
   # It checks if the action is feasible or not.
    
    #:param node: the current node
    #:param action: 0,1,2,3
    #:return: The function isFeasible is returning a boolean value.
    #"""
    x = node.empty[0]
    y = node.empty[1]
    if action == 3:
        return (x >=0 and x <= 2) and (y-1)>=0 and (y-1) <= 2
    elif action == 2:
        return (x+1) >=0 and (x+1) <= 2 and y>=0 and y <= 2
    elif action == 1:
        return x >=0 and x <= 2 and (y+1)>=0 and (y+1) <=2
    elif action == 0:
        return (x-1) >=0 and (x-1) <= 2 and y>=0 and y <= 2

#Goal Function
    
def checkFinalState(node):
   # """
   # It checks if the current state is the final state.
    
   # :param node: the node to check
   # :return: a boolean value.
   # """
    FINAL_STATE = [
        [0,1,2],
        [3,4,5],
        [6,7,8]
    ]
    for row in range(3):
        for col in range(3):
            if FINAL_STATE[row][col] != node.state[row][col]:
                return False

    return True

#For Printing states

def printState(sol):
   # """
   # It prints the solution in a nice format
    
   # :param sol: the solution to the puzzle
   # """
    for state in sol:
        for row in state:
            for col in row:
                print(col, end=" ")
            print()
        print()

#Check if this node is already visited

def isVisited(visited, pstate):
   # """
    #If the current state is not in the visited list, return False, else return True
    
    #:param visited: A list of all the states that have been visited
    #:param pstate: The current state of the puzzle
    #:return: The function isVisited() returns True if the state is already visited, else it returns
    #False.
    #"""
    if not visited:
        return False
    for state in visited:
        for row in range(3):
            flag = 0
            for col in range(3):
                if state[row][col] != pstate[row][col]:
                    flag = 1
                    break
            if flag:
                break
        if not flag:
            return True
    return False

#Check if the 8 puzzle problem is solvable.

def isSolvable(state):
   # """
   # It takes a state as input, and returns True if the state is solvable, and False otherwise.
    
   # :param state: the current state of the puzzle
   # :return: The function isSolvable is returning a boolean value.
   # """
    state_array = [col for row in state for col in row]
    state_array.pop(state_array.index(0))
    count = 0
    for i in range(len(state_array)):
        for j in range(i+1,len(state_array)):
            if (state_array[j] < state_array[i]):
                count+=1
    return (count%2)==0

#Search continuously through the search space using dfs(order: top,right,down,left)

def play_game(node, solution, visited):
   # """
    #It takes a node, a solution dictionary, and a list of visited states. If the node is a solution, it
    #adds the path to the solution dictionary. Otherwise, it checks if the node is feasible in each
    #direction, and if it is, it creates a new node and recursively calls the function on that node.
    
    #:param node: the current node
    #:param solution: a dictionary that contains all the solutions found so far. The key is the length of
    #the solution, and the value is a list of solutions of that length
    #:param visited: a list of all the states that have been visited
    #:return: A dictionary of lists of lists.
    #"""
    if (checkFinalState(node)):
        '''
        if this is a solution, add its path to the sol list and continue the search in the hope of finding a better one
        '''
        sol = []
        iter = node
        while (iter):
            sol.append(iter.state)
            iter = iter.parent
        if node.level not in solution.keys():
            solution[node.level] = []
        solution[node.level].append(sol)
        return solution
    action = {'top':0, 'right':1, 'left':3, 'down':2}
    visited.append(node.state)
    if isFeasible(node, action['top']):
        state = [[] for i in node.state]
        for index in range(len(node.state)):
            state[index].extend(node.state[index])
        empty = (node.empty[0]-1, node.empty[1])
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
        if not isVisited(visited, state):
            newNode = Node(state, node, node.level+1, empty)
            solution = play_game(newNode, solution, visited)
    if isFeasible(node, action['right']):
        state = [[] for i in node.state]
        for index in range(len(node.state)):
            state[index].extend(node.state[index])
        empty = (node.empty[0], node.empty[1]+1)
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
        if not isVisited(visited, state):
            newNode = Node(state, node, node.level+1, empty)
            solution = play_game(newNode, solution, visited)
    if isFeasible(node, action['down']):
        state = [[] for i in node.state]
        for index in range(len(node.state)):
            state[index].extend(node.state[index])
        empty = (node.empty[0]+1, node.empty[1])
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
        if not isVisited(visited, state):
            newNode = Node(state, node, node.level+1, empty)
            solution = play_game(newNode, solution, visited)
    if isFeasible(node, action['left']):
        state = [[] for i in node.state]
        for index in range(len(node.state)):
            state[index].extend(node.state[index])
        empty = (node.empty[0], node.empty[1]-1)
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
        if not isVisited(visited, state):
            newNode = Node(state, node, node.level+1, empty)
            solution = play_game(newNode, solution, visited)
    return solution

#Main Function
    
def main():
    state = [
        [3,1,2],
        [0,4,5],
        [6,7,8]
    ]
    empty = (1,0)
    parent = None
    level = 0
    initial = Node(state, parent, level, empty)
    solution = {}
    visited = []
    if isSolvable(state):
        sol = play_game(initial, solution, visited)
    else:
        print("Not Solvable")
        return
    import operator as op
    sorted_solution = sorted(sol.items(), key = op.itemgetter(0))
    final_sol = sorted_solution[0][1][0]
    printState(final_sol)


if __name__ == '__main__':
    main()

#class for storing node metadata
class Node:
    def __init__(self, state, parent, level, empty):
        self.state = state
        self.parent = parent
        self.level = level
        self.empty = empty
    
#Check if empty block can move to a particular side

def isFeasible(node, action):
    x = node.empty[0]
    y = node.empty[1]
    if action == 3:
        return (x >=0 and x <= 2) and (y-1)>=0 and (y-1) <= 2
    elif action == 2:
        return (x+1) >=0 and (x+1) <= 2 and y>=0 and y <= 2
    elif action == 1:
        return x >=0 and x <= 2 and (y+1)>=0 and (y+1) <= 2
    elif action == 0:
        return (x-1) >=0 and (x-1) <= 2 and y>=0 and y <= 2

#Goal Function
    
def checkFinalState(node):
    FINAL_STATE = [
        [0,1,2],
        [3,4,5],
        [6,7,8]
    ]
    for row in range(3):
        for col in range(3):
            if FINAL_STATE[row][col] != node.state[row][col]:
                return False

    return True

#Print State

def printState(sol):
    for state in sol:
        for row in state:
            for col in row:
                print(col, end=" ")
            print()
        print()

#Check if this node is previously visited

def isVisited(visited, pstate):
    if not visited:
        return False
    for state in visited:
        for row in range(3):
            flag = 0
            for col in range(3):
                if state[row][col] != pstate[row][col]:
                    flag = 1
                    break
            if flag:
                break
        if not flag:
            return True
    return False

#Approximate the next optimal node to visit

def calculateCost(node, action):
    FINAL_STATE = [
        [0,1,2],
        [3,4,5],
        [6,7,8]
    ]
    state = [[] for i in node.state]
    for index in range(len(node.state)):
        state[index].extend(node.state[index])
    if action==0:
        empty = (node.empty[0]-1, node.empty[1])
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
    elif action==1:
        empty = (node.empty[0], node.empty[1]+1)
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
    elif action==2:
        empty = (node.empty[0]+1, node.empty[1])
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
    elif action==3:
        empty = (node.empty[0], node.empty[1]-1)
        state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
    invalid_nodes = 0
    for row in range(3):
        for col in range(3):
            if FINAL_STATE[row][col] != state[row][col]:
                invalid_nodes += 1
    return node.level+invalid_nodes+1

#Check if the 8 puzzle problem is solvable.

def isSolvable(state):
    state_array = [col for row in state for col in row]
    state_array.pop(state_array.index(0))
    count = 0
    for i in range(len(state_array)):
        for j in range(i+1,len(state_array)):
            if (state_array[j] < state_array[i]):
                count+=1
    return (count%2)==0

#At each step choose the next possible node wisely using the utility calculateCost

def play_game(node, solution, visited):
    if solution:
        return True
    if (checkFinalState(node)):
        sol = []
        iter = node
        while (iter):
            sol.append(iter.state)
            iter = iter.parent
        printState(sol)
        return True
    action = {'top':0, 'right':1, 'left':3, 'down':2}
    cost = {}
    if isFeasible(node, action['top']):
        cost[0] = calculateCost(node, action['top'])
    if isFeasible(node, action['right']):
        cost[1] = calculateCost(node, action['right'])
    if isFeasible(node, action['down']):
        cost[2] = calculateCost(node, action['down'])
    if isFeasible(node, action['left']):
        cost[3] = calculateCost(node, action['left'])
    import operator as op
    sorted_cost = dict(sorted(cost.items(), key=op.itemgetter(1)))
    visited.append(node.state)
    for key in sorted_cost:
        if key == 0:
            state = [[] for i in node.state]
            for index in range(len(node.state)):
                state[index].extend(node.state[index])
            empty = (node.empty[0]-1, node.empty[1])
            state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
            if not isVisited(visited, state):
                newNode = Node(state, node, node.level+1, empty)
                solution = play_game(newNode, solution, visited)
        elif key == 1:
            state = [[] for i in node.state]
            for index in range(len(node.state)):
                state[index].extend(node.state[index])
            empty = (node.empty[0], node.empty[1]+1)
            state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
            if not isVisited(visited, state):
                newNode = Node(state, node, node.level+1, empty)
                solution = play_game(newNode, solution, visited)
        elif key == 2:
            state = [[] for i in node.state]
            for index in range(len(node.state)):
                state[index].extend(node.state[index])
            empty = (node.empty[0]+1, node.empty[1])
            state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
            if not isVisited(visited, state):
                newNode = Node(state, node, node.level+1, empty)
                solution = play_game(newNode, solution, visited)
        elif key == 3:
            state = [[] for i in node.state]
            for index in range(len(node.state)):
                state[index].extend(node.state[index])
            empty = (node.empty[0], node.empty[1]-1)
            state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
            if not isVisited(visited, state):
                newNode = Node(state, node, node.level+1, empty)
                solution = play_game(newNode, solution, visited)
        if solution:
            return True

def main():
    state = [
        [1,2,0],
        [3,4,5],
        [6,7,8]
    ]
    empty = (0,2)
    parent = None
    level = 0
    initial = Node(state, parent, level, empty)
    solution = False
    visited = []
    if (isSolvable(state)):
        solution = play_game(initial, solution, visited)
    else:
        print("Not solvable")
        return

if __name__ == '__main__':
    main()

#class to define a node in search space

# The Node class is used to create a node object that contains the state of the board, the parent
# node, the level of the node, and the location of the empty space
class Node:
    def __init__(self, state, parent, level, empty):
        self.state = state
        self.parent = parent
        self.level = level
        self.empty = empty

#Check if empty block can move to a particular side
#It checks if the action is feasible or not.
    
 #   :param node: the current node
  #  :param action: 0,1,2,3
   # :return: The function isFeasible is returning a boolean value.
def isFeasible(node, action):
    x = node.empty[0]
    y = node.empty[1]
    if action == 3:
        return (x >=0 and x <= 2) and (y-1)>=0 and (y-1) <= 2
    elif action == 2:
        return (x+1) >=0 and (x+1) <= 2 and y>=0 and y <= 2
    elif action == 1:
        return x >=0 and x <= 2 and (y+1)>=0 and (y+1) <=2
    elif action == 0:
        return (x-1) >=0 and (x-1) <= 2 and y>=0 and y <= 2

#Goal Function

def checkFinalState(node):
    #"""
   # It checks if the current state of the node is the same as the final state
    
    #:param node: The node to check
    #:return: a boolean value.
    #"""
    FINAL_STATE = [
        [0,1,2],
        [3,4,5],
        [6,7,8]
    ]
    for row in range(3):
        for col in range(3):
            if FINAL_STATE[row][col] != node.state[row][col]:
                return False

    return True

#Print State

def printState(sol):
   # """
    #It prints the solution in a nice format
    
    #:param sol: the solution to the puzzle
    #"""
    for state in sol:
        for row in state:
            for col in row:
                print(col, end=" ")
            print()
        print()

#Check if the node is already visited

def isVisited(visited, explored, pstate):
   # """
   # It checks if the current state is already visited or not.
    
   # :param visited: list of all visited states
   # :param explored: list of nodes that have been explored
   # :param pstate: The current state of the puzzle
   # :return: the path to the goal state.
    #"""
    visited.extend(explored)
    if not visited:
        return False
    for state in visited:
        for row in range(3):
            flag = 0
            for col in range(3):
                if state.state[row][col] != pstate[row][col]:
                    flag = 1
                    break
            if flag:
                break
        if not flag:
            return True
    return False

#Check if the 8 puzzle problem is solvable.

def isSolvable(state):
   # """
    #It takes a state as input, and returns True if the state is solvable, and False otherwise
    
   # :param state: The current state of the puzzle
   # :return: a boolean value.
   # """
    state_array = [col for row in state for col in row]
    state_array.pop(state_array.index(0))
    count = 0
    for i in range(len(state_array)):
        for j in range(i+1,len(state_array)):
            if (state_array[j] < state_array[i]):
                count+=1
    return (count%2)==0

#Loop through the search space horizontally using bfs and stop when the goal state is found

def play_game(node, visited):
   # """
    #It takes a node and a list of visited nodes as input, and returns True if the node is the final
   # state, and False otherwise
    
    #:param node: the current node
    #:param visited: a list of nodes that have been visited
    #:return: a boolean value.
    #"""
    if not isSolvable(node.state):
        print("Not Solvable")
        return 
    action = {'top':0, 'right':1, 'left':3, 'down':2}
    explored = []
    while(len(visited)!=0):
        node = visited[0]
        for key in action:
            if key == 'top' and isFeasible(node, action['top']):
                state = [[] for i in node.state]
                for index in range(len(node.state)):
                    state[index].extend(node.state[index])
                empty = (node.empty[0]-1, node.empty[1])
                state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
                if not isVisited(visited, explored, state):
                    newNode = Node(state, node, node.level+1, empty)
            elif key == 'right' and isFeasible(node, action['right']):
                state = [[] for i in node.state]
                for index in range(len(node.state)):
                    state[index].extend(node.state[index])
                empty = (node.empty[0], node.empty[1]+1)
                state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
                if not isVisited(visited, explored, state):
                    newNode = Node(state, node, node.level+1, empty)
            elif key == 'down' and isFeasible(node, action['down']):
                state = [[] for i in node.state]
                for index in range(len(node.state)):
                    state[index].extend(node.state[index])
                empty = (node.empty[0]+1, node.empty[1])
                state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
                if not isVisited(visited, explored, state):
                    newNode = Node(state, node, node.level+1, empty)
            elif key == 'left' and isFeasible(node, action['left']):
                state = [[] for i in node.state]
                for index in range(len(node.state)):
                    state[index].extend(node.state[index])
                empty = (node.empty[0], node.empty[1]-1)
                state[node.empty[0]][node.empty[1]], state[empty[0]][empty[1]] = state[empty[0]][empty[1]], state[node.empty[0]][node.empty[1]]
                if not isVisited(visited, explored, state):
                    newNode = Node(state, node, node.level+1, empty)
            visited.append(newNode)
            if (checkFinalState(newNode)):
                sol = []
                iter = newNode
                while (iter):
                    sol.append(iter.state)
                    iter = iter.parent
                printState(sol)
                return True
        explored.append(visited.pop(0))
    return None

def main():
    #"""
    #The function play_game takes in a node and a list of visited nodes, and returns a node that is the
    #solution to the puzzle
    #"""
    state = [
        [3,1,2],
        [4,0,5],
        [6,7,8]
    ]
    empty = (1,1)
    parent = None
    level = 0
    initial = Node(state, parent, level, empty)
    visited = [initial]
    sol = play_game(initial, visited)

if __name__ == '__main__':
    main()

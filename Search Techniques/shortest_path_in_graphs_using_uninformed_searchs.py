# -*- coding: utf-8 -*-
"""420251_Week2_Assignment-01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NBMQM1M0uDFkuM3t4TfTmavGTMtINeUJ
"""

class Node:
    '''
    Node to hold the metadata about the vertex in the graph.
    '''

    def __init__(self, vertex, parent):
        self.vertex = vertex
        self.parent = parent

def goal_test(node, end):
    '''
    Check if the goal state is arrived.
    '''
    return node == end

def solution(start):
    '''
    Function to print the path of goal state.
    '''
    iter = start
    while(iter):
        print(iter.vertex)
        iter = iter.parent
    return True

def isExplored(explored, vertex):
    '''
    Checks if a given vertex is already explored or not.
    '''
    vertices = [ver.vertex for ver in explored]
    return vertex in vertices


import operator as op
def dfs(graph, start, end, explored):
    '''
    Search through each branch deep down the space and if not found 
    come back to the start and search through the other branch.

    The nodes at the same level are chosen in the order of their path costs.
    '''
    if goal_test(start.vertex, end):
        return solution(start)
    explored.append(start)
    children = dict(sorted(graph[start.vertex].items(), key=op.itemgetter(1)))
    for child in children.keys():
        if not isExplored(explored, child):
            newNode = Node(child, start)
            result = dfs(graph, newNode, end, explored)
            if result:
                return result
    return False

def make_undirected_graph(graph):
    '''
    Computes a undirected graph using the given graph.
    The given should have edges along one direction only.
    '''
    import copy
    final_graph = copy.deepcopy(graph)

    for key in graph.keys():
        for inner_key in graph[key].keys():

            if inner_key in final_graph.keys():
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
            else:
                final_graph[inner_key] = {}
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
    return final_graph

def main():
    graph = dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142))

    graph = make_undirected_graph(graph)

    start = Node('Arad', None)
    end = 'Bucharest'
    explored = []
    print(dfs(graph, start, end, explored))

if __name__ == '__main__':
    main()

"""![1.png](data:image/png;base64,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)"""

class Node:
    '''
    Node to hold the metadata about the vertex in the graph.
    '''

    def __init__(self, vertex, parent):
        self.vertex = vertex
        self.parent = parent

def goal_test(node, end):
    '''
    Check if the goal state is arrived.
    '''
    return node == end

def solution(start):
    '''
    Function to print the path of goal state.
    '''
    iter = start
    while(iter):
        print(iter.vertex)
        iter = iter.parent
    return True

def isExplored(explored, vertex):
    '''
    Checks if a given vertex is already explored or not.
    '''
    vertices = [ver.vertex for ver in explored]
    return vertex in vertices

import operator as op
def bfs(graph, start, end):
    '''
    Visit all the nodes at the same level first.

    It is complete and not optimal as the edge costs are not same.
    '''
    if goal_test(start.vertex, end):
        return solution(start)
    frontier = [start]
    explored = []
    while len(frontier)!=0:
        node = frontier.pop(0)
        explored.append(node)
        for child in graph[node.vertex].keys():
            if not isExplored(explored, child):
                newNode = Node(child, node)
                if goal_test(child, end):
                    return solution(newNode)
                frontier.append(newNode)
    return False

def make_undirected_graph(graph):
    '''
    Computes a undirected graph using the given graph.
    The given should have edges along one direction only.
    '''
    import copy
    final_graph = copy.deepcopy(graph)

    for key in graph.keys():
        for inner_key in graph[key].keys():

            if inner_key in final_graph.keys():
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
            else:
                final_graph[inner_key] = {}
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
    return final_graph

def main():
    graph = dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142))

    graph = make_undirected_graph(graph)

    start = Node('Arad', None)
    end = 'Bucharest'
    print(bfs(graph, start, end))

if __name__ == '__main__':
    main()

"""![image.png](data:image/png;base64,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)"""

class Node:
    '''
    Node to hold the metadata about the vertex in the graph.
    '''

    def __init__(self, vertex, parent):
        self.vertex = vertex
        self.parent = parent

def goal_test(node, end):
    '''
    Check if the goal state is arrived.
    '''
    return node == end

def solution(start):
    '''
    Function to print the path of goal state.
    '''
    iter = start
    while(iter):
        print(iter.vertex)
        iter = iter.parent
    return True
    
def isExplored(explored, vertex):
    '''
    Checks if a given vertex is already explored or not.
    '''
    vertices = [ver.vertex for ver in explored]
    return vertex in vertices

import operator as op
def dls(graph, start, end, limit, explored):
    '''
    Depth Limited approach
    '''
    if goal_test(start.vertex, end):
        return solution(start)
    elif limit == 0:
        return False
    else:
        explored.append(start)
        children = dict(sorted(graph[start.vertex].items(), key=op.itemgetter(1)))
        for child in children.keys():
            if not isExplored(explored, child):
                newNode = Node(child, start)
                result = dls(graph, newNode, end, limit-1, explored)
                if result:
                    return result
        return False

def make_undirected_graph(graph):
    '''
    Computes a undirected graph using the given graph.
    The given should have edges along one direction only.
    '''
    import copy
    final_graph = copy.deepcopy(graph)

    for key in graph.keys():
        for inner_key in graph[key].keys():

            if inner_key in final_graph.keys():
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
            else:
                final_graph[inner_key] = {}
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
    return final_graph

def ids(graph, start, end, limit, explored):
    '''
    Use depth limit search to search for the path at a certain limit and 
    increase the limit if the goal state is not found.

    This strategy is not optimal for path involving unequal path lengths.
    '''
    while True:
        result = dls(graph, start, end, limit, explored)
        if result:
            break
        limit+=1
    return result

def main():
    graph = dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142))

    graph = make_undirected_graph(graph)

    start = Node('Sibiu', None)
    end = 'Bucharest'
    explored = []
    limit = 1
    print(ids(graph, start, end, limit, explored))

if __name__ == '__main__':
    main()

"""![image.png](data:image/png;base64,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)"""

class Node:
    '''
    Node to hold the metadata about the vertex in the graph.
    '''

    def __init__(self, vertex, parent):
        self.vertex = vertex
        self.parent = parent

def goal_test(node, end):
    '''
    Check if the goal state is arrived.
    '''
    return node == end

def solution(start):
    '''
    Function to print the path of goal state.
    '''
    iter = start
    while(iter):
        print(iter.vertex)
        iter = iter.parent
    return True
    
def isExplored(explored, vertex):
    '''
    Checks if a given vertex is already explored or not.
    '''
    vertices = [ver.vertex for ver in explored]
    return vertex in vertices

import operator as op
def dls(graph, start, end, limit, explored):
    '''
    Depth Limited approach.

    It is incomplete and hence not optimal.
    '''
    if goal_test(start.vertex, end):
        return solution(start)
    elif limit == 0:
        raise Exception('Limit Reached')
    else:
        explored.append(start)
        children = dict(sorted(graph[start.vertex].items(), key=op.itemgetter(1)))
        for child in children.keys():
            if not isExplored(explored, child):
                newNode = Node(child, start)
                result = dls(graph, newNode, end, limit-1, explored)
                if result:
                    return result
        return False

def make_undirected_graph(graph):
    '''
    Computes a undirected graph using the given graph.
    The given should have edges along one direction only.
    '''
    import copy
    final_graph = copy.deepcopy(graph)

    for key in graph.keys():
        for inner_key in graph[key].keys():

            if inner_key in final_graph.keys():
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
            else:
                final_graph[inner_key] = {}
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
    return final_graph

def main():
    graph = dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142))

    graph = make_undirected_graph(graph)

    start = Node('Sibiu', None)
    end = 'Bucharest'
    explored = []
    limit = 10
    print(dls(graph, start, end, limit, explored))

if __name__ == '__main__':
    main()

"""![image.png](data:image/png;base64,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)"""

class Node:
    '''
    Node to hold the metadata about the vertex in the graph.
    '''

    def __init__(self, vertex, parent):
        self.vertex = vertex
        self.parent = parent

class PriorityQueue:

    def __init__(self, queue=None):
        '''
        Queue should be an instance of class dict
        with keys as the city name and values as their cost.
        '''
        self.queue = {}
        if not isinstance(queue, dict):
            raise Exception("Queue should be an instance of class dict")
        if queue:
            self.queue.update(queue)

    def isEmpty(self):
        return len(self.queue)==0
    
    def push(self, element):
        '''
        Adds the element at the end of the queue if element is of the type dict.
        '''
        if not isinstance(element, dict):
            raise Exception("Element should be an instance of class dict")
        
        self.queue.update(element)
    
    def pop(self):
        '''
        Pop the element with highest priority from the queue if it is not empty. 
        '''
        if self.isEmpty():
            raise Exception('Priority queue is empty')
        max_p = list(self.queue.keys())[0]
        for key in (self.queue.keys()):
            if self.queue[max_p] > self.queue[key]:
                max_p = key
        max_p_dict = {max_p:self.queue[max_p]}
        del self.queue[max_p]
        return max_p_dict
    
    def get_cost(self, node):
        '''
        Return the cost of the node present in the frontier
        '''
        if node not in self.get_nodes():
            raise Exception('Invalid key {}'.format(node))
        
        return self.queue[self.get(node)]

    def get_nodes(self):
        '''
        Get the list of vertices of the nodes in frontier
        '''
        return [ver.vertex for ver in self.queue.keys()]

    def get(self, vertex):
        '''
        Return the node pertaining to the vertex
        '''
        for key in self.queue.keys():
            if key.vertex == vertex:
                return key

        raise Exception("Invalid Vertex") 
    
def goalTest(now, end):
    return now == end

def solution(start):
    '''
    Function to print the path of goal state.
    '''
    iter = start
    while(iter):
        print(iter.vertex)
        iter = iter.parent
    return True

def ucs(graph, start, end):
    '''
    Uniform cost search by using a priority queue as frontier and ordered by the
    path cost of the nodes in the graph.

    It is complete and optimal.
    '''    
    start_dict = {start:0}
    frontier = PriorityQueue(start_dict)
    explored = {}
    
    while not frontier.isEmpty():
        node = frontier.pop()
        city = list(node.items())[0][0]
        cost = list(node.items())[0][1]
        if goalTest(city.vertex, end):
            return solution(city)
        explored.update(node)
        explored_vertices = [ver.vertex for ver in explored.keys()]
        for child in graph[city.vertex].keys():
            if child not in frontier.get_nodes() and child not in explored_vertices:
                newNode = Node(child, city)
                frontier.push({newNode:cost+graph[city.vertex][child]})
            elif child in frontier.get_nodes() and (cost+graph[city.vertex][child]) < frontier.get_cost(child):
                newNode = frontier.get(child)
                newNode.parent = city
                frontier.push({newNode:cost+graph[city.vertex][child]})
    
    return False

def make_undirected_graph(graph):
    '''
    Computes a undirected graph using the given graph.
    The given should have edges along one direction only.
    '''
    import copy
    final_graph = copy.deepcopy(graph)

    for key in graph.keys():
        for inner_key in graph[key].keys():

            if inner_key in final_graph.keys():
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
            else:
                final_graph[inner_key] = {}
                final_graph[inner_key].update({key:final_graph[key][inner_key]})
    return final_graph

def main():
    graph = dict(
    Arad=dict(Zerind=75, Sibiu=140, Timisoara=118),
    Bucharest=dict(Urziceni=85, Pitesti=101, Giurgiu=90, Fagaras=211),
    Craiova=dict(Drobeta=120, Rimnicu=146, Pitesti=138),
    Drobeta=dict(Mehadia=75),
    Eforie=dict(Hirsova=86),
    Fagaras=dict(Sibiu=99),
    Hirsova=dict(Urziceni=98),
    Iasi=dict(Vaslui=92, Neamt=87),
    Lugoj=dict(Timisoara=111, Mehadia=70),
    Oradea=dict(Zerind=71, Sibiu=151),
    Pitesti=dict(Rimnicu=97),
    Rimnicu=dict(Sibiu=80),
    Urziceni=dict(Vaslui=142))

    graph = make_undirected_graph(graph)

    start = Node('Arad', None)

    end = 'Bucharest'

    print(ucs(graph, start, end))
    

if __name__ == '__main__':
    main()

"""![image.png](data:image/png;base64,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)"""
